/@ Sample code for Project 3 to test all required grammar rules @/

// Rule 40, 41: include_command → include ( F_name.txt );
include (utils.txt);
include (includeTest.txt); // Testing include with includeTest.txt
// Rule 39: comment → /^ STR
/^ Testing single-line comment

// Rules 5, 6: var-declaration → type-specifier ID ; | type-specifier → Imw | SIMw | Chj | Series | IMwf | SIMwf | NOReturn
Imw global_var; // Global variable declaration (allowed anywhere)
Series str_var;

// Rule 2, 3: declaration-list → declaration d_list | d_list → declaration d_list | ε
// Rule 7, 8, 9, 10, 11: fun-declaration → type-specifier ID ( params ) compound-stmt | params → param-list | NOReturn | ε
// Rule 12: compound-stmt → { local-declarations statement-list }
NOReturn main() {
    // Rule 13: local-declarations → local-declarations var-declaration | ε
    Imw x; // Local variable declaration
    Imw y;

    // Initialization allowed only inside functions
    x = 5; // Valid initialization
    y = x + 10;

    // Rule 16: expression-stmt → expression ; | ;
    ; // Empty expression statement

    // Rule 17: selection-stmt → IfTrue ( expression ) statement | IfTrue ( expression ) statement Otherwise statement
    IfTrue (x > 0) {
        x = x + 1;
    } Otherwise {
        x = 0;
    }

    // Rule 18: iteration-stmt → RepeatWhen ( expression ) statement
    RepeatWhen (x < 10) {
        x = x + 1;
    }

    // Rule 18: iteration-stmt → Reiterate ( expression ; expression ; expression ) statement
    Reiterate (x = 0; x < 5; x = x + 1) {
        y = y + x;
    }

    // Rule 19: jump-stmt → Turnback expression ;
    Turnback x;

    // Rule 19: jump-stmt → Stop ;
    Stop;
}

// Rule 7: fun-declaration with params
Imw add(Imw a, Imw b) {
    // Rule 20, 21, 22, 23, 24, 25, 26, 27: expression → id-assign = expression | simple-expression
    // simple-expression → additive-expression relop additive-expression | additive-expression
    Imw result;
    result = a + b * 2; // Testing addop, mulop, and expression
    IfTrue (result != 0) {
        result = result - 1;
    }
    Turnback result;
}

// Rule 12: compound-stmt with comment
/@ Function with comment @/
SIMw process() {
    SIMw p;
    p = 10;
}

// Rule 5: struct declaration (Loli as STRUCT)
Loli Point {
    Imw x;
    Imw y;
};

// Rule 29: call → ID ( args ) | Rule 30, 31, 32: args → arg-list | ε | arg-list → expression a_list
Imw test_call() {
    Imw res;
    res = add(5, 10); // Function call with arguments
    Turnback res;
}

// Rule 33-38: num → Signed num | Unsigned num | value → INT_NUM | FLOAT_NUM
Imw test_numbers() {
    Imw n1;
    IMwf n2;
    n1 = +10; // Signed positive number
    n2 = -3.14; // Signed negative float
    Turnback n1;
}